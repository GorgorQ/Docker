1-1 For which reason is it better to run the container with a flag -e to give the environment variables 
rather than put them directly in the Dockerfile?

Becaause without the -e flag, the credentials are visible for anyone having the image. 
They only need to do tis comand : docker history my-image, to get the env variables in plain text, 
which is a major security issue.

1-2 Why do we need a volume to be attached to our postgres container?

We need a volume attached to our postgres container for data persistence. Without a volume, all data 
stored in the database is kept only in the container's writable layer. When the container is stopped 
or destroyed (docker rm), all the data is permanently lost.

1-3 Document your database container essentials: commands and Dockerfile.

Dockerfile:
FROM postgres:17.2-alpine
COPY 01-CreateScheme.sql /docker-entrypoint-initdb.d/
COPY 02-InsertData.sql /docker-entrypoint-initdb.d/

Essential Commands:
- Create network: docker network create app-network
- Create volume: docker volume create postgres-data
- Build image: docker build -t my-postgres-db .
- Run container: docker run --name postgres-container --network app-network --env-file .env 
  -v postgres-data:/var/lib/postgresql/data -d my-postgres-db
- Run Adminer: docker run -p "8090:8080" --net=app-network --name=adminer -d adminer

The Dockerfile copies SQL initialization scripts that are automatically executed on first startup.
Environment variables (POSTGRES_DB, POSTGRES_USER, POSTGRES_PASSWORD) are passed via .env file for security.

1-4 Why do we need a multistage build? And explain each step of this dockerfile.

We need a multistage build to:
- Reduce final image size by excluding build tools (JDK, Maven) from the runtime image
- Separate build and runtime environments
- Improve security by reducing attack surface (fewer tools in production)
- Avoid requiring Maven and JDK on the host machine

Dockerfile explanation:

BUILD STAGE:
FROM eclipse-temurin:21-jdk-alpine AS myapp-build
  -> Uses JDK image for compilation, names this stage "myapp-build"
ENV MYAPP_HOME=/opt/myapp
  -> Sets environment variable for application directory
WORKDIR $MYAPP_HOME
  -> Sets working directory to /opt/myapp
RUN apk add --no-cache maven
  -> Installs Maven package manager (Alpine uses apk)
COPY pom.xml . and COPY src ./src
  -> Copies project configuration and source code
RUN mvn package -DskipTests
  -> Compiles the application into a JAR file in target/ directory

RUN STAGE:
FROM eclipse-temurin:21-jre-alpine
  -> New stage with JRE only (no JDK, no Maven) - much smaller
ENV MYAPP_HOME=/opt/myapp and WORKDIR $MYAPP_HOME
  -> Sets same working directory
COPY --from=myapp-build $MYAPP_HOME/target/*.jar $MYAPP_HOME/myapp.jar
  -> Copies ONLY the compiled JAR from build stage (not source code or build tools)
ENTRYPOINT ["java", "-jar", "myapp.jar"]
  -> Defines the command to run when container starts

Result: Final image contains only JRE + JAR file, reducing size from ~500MB to ~200MB.